while adding subject getting infinite response -> in addSubject service method
        ->sol: make a dtos rather then use a @JsonIgnore and @JsonBackReferances and @JsonManagedReferances

Remainng : adding logging(slf4j) and validation : Done




@Entity
@Data
@FieldDefaults(level = AccessLevel.PRIVATE)
public class Exam {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    Long examId;
    Date examDate;
    @ManyToOne
    @JoinColumn(name = "exam_type_id")
    ExamType examType;

    // Many Exams belong to one Subject
    @ManyToOne
    @JoinColumn(name = "subjects_id")
    Subject subjects;

    @OneToMany(mappedBy = "exam", cascade = CascadeType.ALL)
    List<Result> results = new ArrayList<>();

}


package com.school.entity;

import jakarta.persistence.*;
import lombok.AccessLevel;
import lombok.Data;
import lombok.experimental.FieldDefaults;

import java.util.ArrayList;
import java.util.List;

@Entity
@Data
@FieldDefaults(level = AccessLevel.PRIVATE)
@Table(name = "examtypes")
public class ExamType {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    Long examTypeId;
    String examTypeName;
    @OneToMany(mappedBy = "examType", cascade = CascadeType.ALL)
    List<Exam> exams=new ArrayList<>() ;



}


package com.school.entity;

import jakarta.persistence.*;
import lombok.AccessLevel;
import lombok.Data;
import lombok.experimental.FieldDefaults;

import java.util.Date;

@Entity
@Table(name = "results")
@Data
@FieldDefaults(level = AccessLevel.PRIVATE)
public class Result {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    Long resultId;

    // Pass/Fail status
    String status;
    // Date of result or evaluation
    Date resultDate;

    @ManyToOne
    @JoinColumn(name = "user_id")
    Users users;

    @ManyToOne
    @JoinColumn(name = "exam_id")
    Exam exam;

    @Override
    public String toString() {
        return "Result{" +
                "resultId=" + resultId +
                ", status='" + status + '\'' +
                ", resultDate=" + resultDate +
//                ", users=" + users +
//                ", exam=" + exam +
                '}';
    }
}


package com.school.entity;

import jakarta.persistence.*;
import lombok.AccessLevel;
import lombok.Data;
import lombok.experimental.FieldDefaults;
import java.util.ArrayList;
import java.util.List;

@Entity
@Data
@FieldDefaults(level = AccessLevel.PRIVATE)
@Table(name = "subjects")
public class Subject {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    Long subjectId;
    String subjectName;
    Double subjectScore;
    // Many Subjects belong to one Course
    @ManyToOne
//    @JsonIgnore
    @JoinColumn(name = "course_id")
    Course course;

    //Here Subject is a Parent Table For the Exam Table : for that we are putting f.k in the Exam Table (child Table)
    //One Subject Have Many Exam
    @OneToMany(mappedBy = "subjects", cascade = CascadeType.ALL)
    List<Exam> exam=new ArrayList<>();


}



package com.school.entity;

import com.fasterxml.jackson.annotation.JsonBackReference;
import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import lombok.AccessLevel;
import lombok.Data;
import lombok.experimental.FieldDefaults;

@Entity
@Data
@FieldDefaults(level = AccessLevel.PRIVATE)
public class UserDetails {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    Long userDetailId;
    String details;
    String address;
    String phone;
}

package com.school.entity;

import jakarta.persistence.*;
import lombok.AccessLevel;
import lombok.Data;
import lombok.ToString;
import lombok.experimental.FieldDefaults;

import java.util.ArrayList;
import java.util.List;




@Entity
@Data
@FieldDefaults(level = AccessLevel.PRIVATE)
@Table(name = "courses")

public class Course {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    Long courseId;

    String courseName;
    String courseDescription;

    //Course Table is Parent Table for the Student Table: for that we are putting the f.k in the Student Table (Child Table)
//    @JsonIgnore
    @OneToMany(mappedBy = "course", cascade = CascadeType.ALL)

    List<Subject> subjects = new ArrayList<>();

    @JsonIgnore
    @ManyToMany(mappedBy = "courses")
    List<Users> users = new ArrayList<>();

    @Override
    public String toString() {
        return "Course{" +
                "courseId=" + courseId +
                ", courseName='" + courseName + '\'' +
                ", courseDescription='" + courseDescription + '\'' +
                ", subjects=" + subjects +
                ", users=" + users +
                '}';
    }
}
@Data
@Entity
@FieldDefaults(level = AccessLevel.PRIVATE)
public class Users {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    Long userId;
    String firstName;
    String lastName;
    String email;

    //one-to-one relation with the user details entity
    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn(name = "user_detail_id")
    UserDetails userDetails;

    //many-to-one relation with usertype entity
    @ManyToOne
    @JoinColumn(name = "user_type_id")
    UserType userType;

    @OneToMany(mappedBy = "users", cascade = CascadeType.ALL)
    List<Result> results = new ArrayList<>();

    //many-to-many relationship with the course entity
    @ManyToMany
    @ToString.Exclude
    @JoinTable(
            name = "user_courses",
            joinColumns = @JoinColumn(name = "user_id"),
            inverseJoinColumns = @JoinColumn(name = "course_id")
    )
    List<Course> courses = new ArrayList<>();

    @Override
    public String toString() {
        return "Users{" +
                "userId=" + userId +
                ", firstName='" + firstName + '\'' +
                ", lastName='" + lastName + '\'' +
                ", email='" + email + '\'' +
                ", userDetails=" + userDetails +
                ", userType=" + userType +
                ", results=" + results +
                '}';
    }
}

package com.school.entity;

import jakarta.persistence.*;
import lombok.AccessLevel;
import lombok.Data;
import lombok.experimental.FieldDefaults;

@Entity
@Data
@FieldDefaults(level = AccessLevel.PRIVATE)
public class UserType {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    Long userTypeId;
    String userTypes;

//    @OneToMany(mappedBy = "userType",cascade = CascadeType.ALL)
//    List<Users> users;
}














====================================================


package com.school.repository;

import com.school.dto.CourseSubjectExamResultDTO;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface CourseRepository extends JpaRepository<Course, Long> {

    @Query("SELECT new com.school.dto.CourseSubjectExamResultDTO(" +
           "c.courseId, c.courseName, s.subjectId, s.subjectName, e.examId, e.examName, " +
           "e.examType.examTypeId, e.examType.examTypeName, s.subjectScore, e.examDate, " +
           "r.resultId, r.status, r.resultDate) " +
           "FROM Course c " +
           "JOIN c.subjects s " +
           "JOIN s.exam e " +
           "LEFT JOIN e.results r " +
           "WHERE c IN (SELECT uc.course FROM UserCourses uc WHERE uc.user.userId = :userId)")
    List<CourseSubjectExamResultDTO> findCourseSubjectExamResultsByUserId(@Param("userId") Long userId);
}


package com.school.dto;

import java.util.Date;

public class CourseSubjectExamResultDTO {
    private Long courseId;
    private String courseName;
    private Long subjectId;
    private String subjectName;
    private Long examId;
    private String examName;
    private Long examTypeId;
    private String examTypeName;
    private Double subjectScore;
    private Date examDate;
    private Long resultId;
    private String status;
    private Date resultDate;

    // Getters and Setters
}


=============================

{

  "examDate": "2025-07-21",
  "examType": {
    "examTypeId":2
  },
  "subjects": {
    "subjectId":16
  }
}



https://useful.codes/handling-user-roles-and-permissions-in-spring-boot/


https://www.marcobehler.com/guides/spring-security


youtoub link for spring security: https://www.youtube.com/playlist?list=PLEocw3gLFc8X_a8hGWGaBnSkPFJmbb8QP







Certainly! Let's delve into the Spring Security authentication workflow, as depicted in the provided diagram:

---

### üîç Step-by-Step Breakdown

1. **User Enters Credentials**:

   * The user submits their login credentials, typically through a login form.

2. **Authentication Filter**:

   * The request is intercepted by an authentication filter (e.g., `UsernamePasswordAuthenticationFilter`).
   * This filter extracts the credentials from the request and creates an `Authentication` object, such as `UsernamePasswordAuthenticationToken`.

3. **AuthenticationManager**:

   * The `AuthenticationManager` is responsible for processing the authentication request.
   * It delegates the authentication process to one or more `AuthenticationProvider` instances.

4. **AuthenticationProvider**:

   * Each `AuthenticationProvider` handles a specific type of authentication.
   * For username/password authentication, the `DaoAuthenticationProvider` is commonly used.
   * The provider's `authenticate()` method is invoked to validate the credentials.

5. **UserDetailsService**:

   * The `AuthenticationProvider` calls the `UserDetailsService` to load user-specific data.
   * The `UserDetailsService` retrieves user information from a data source (e.g., database) and returns a `UserDetails` object.

6. **Authentication Object Creation**:

   * If the credentials are valid, the `AuthenticationProvider` creates a fully populated `Authentication` object.
   * This object contains the authenticated user's details and authorities.

7. **AuthenticationManager Returns Authentication**:

   * The `AuthenticationManager` receives the authenticated `Authentication` object from the provider.

8. **Security Context**:

   * The `Authentication` object is stored in the `SecurityContextHolder`.
   * This context holds the authentication information for the current thread of execution.

9. **Security Context Holder**:

   * The `SecurityContextHolder` ensures that the authentication information is accessible throughout the application.

10. **Security Context**:

    * The `SecurityContext` is used by various components to perform authorization checks and access control.

11. **Authentication Success**:

    * If authentication is successful, the user gains access to the requested resources.

---

### üß† Key Components

* **Authentication Filter**: Intercepts authentication requests and initiates the authentication process.
* **AuthenticationManager**: Coordinates the authentication process by delegating to appropriate providers.
* **AuthenticationProvider**: Validates credentials and creates authenticated `Authentication` objects.
* **UserDetailsService**: Loads user-specific data for authentication and authorization.
* **SecurityContextHolder**: Stores the `SecurityContext` containing authentication information.

---

### ‚ö†Ô∏è Important Considerations

* **Password Encoding**: Always use a strong password encoder (e.g., `BCryptPasswordEncoder`) to securely handle passwords.
* **Session Management**: By default, Spring Security uses HTTP sessions to manage authentication. For stateless applications (e.g., REST APIs), consider using token-based authentication (e.g., JWT).
* **Authorization**: After authentication, Spring Security uses the `GrantedAuthority` objects to perform authorization checks, determining what resources the authenticated user can access.

---

If you have further questions or need more detailed explanations on any of these steps, feel free to ask!





=====================================Step By Step with Data =======================================
Certainly! Let's delve into the Spring Security authentication flow with a concrete example, illustrating each step with data as a user submits their credentials.

---

### üß© Spring Security Authentication Flow with Example

#### 1. **User Submits Login Form**

* **Request**: `POST /login`

* **Payload**:

  ```json
  {
    "username": "john_doe",
    "password": "securePassword123"
  }
  ```

#### 2. **Request Interception by Security Filter Chain**

* The request is intercepted by the **Security Filter Chain**, which includes various filters such as `SecurityContextPersistenceFilter`, `UsernamePasswordAuthenticationFilter`, and others.([Medium][1])

* The `UsernamePasswordAuthenticationFilter` is specifically responsible for handling authentication requests.

#### 3. **Authentication Filter Creates Authentication Token**

* The `UsernamePasswordAuthenticationFilter` extracts the credentials from the request and creates an `Authentication` object:

  ```java
  Authentication authentication = new UsernamePasswordAuthenticationToken(
      "john_doe", "securePassword123");
  ```

  * At this point, the `authentication` object is not authenticated (`isAuthenticated = false`).([frugalisminds.com][2])

#### 4. **AuthenticationManager Processes Authentication**

* The `AuthenticationManager` receives the `authentication` object and delegates the authentication process to an appropriate `AuthenticationProvider`.

* In this case, the `DaoAuthenticationProvider` is typically used, which relies on a `UserDetailsService` to load user-specific data.

#### 5. **AuthenticationProvider Verifies Credentials**

* The `DaoAuthenticationProvider` calls the `UserDetailsService` to load the user details:

  ```java
  UserDetails userDetails = userDetailsService.loadUserByUsername("john_doe");
  ```

  * Assume the `UserDetails` object contains:

    ```java
    UserDetails userDetails = new User(
        "john_doe", "{bcrypt}$2a$10$DowJonesIndex",
        Arrays.asList(new SimpleGrantedAuthority("ROLE_USER")));
    ```

  * The password is encoded using BCrypt.

* The `DaoAuthenticationProvider` compares the provided password with the stored password using the configured `PasswordEncoder`.

  ```java
  boolean passwordsMatch = passwordEncoder.matches(
      "securePassword123", userDetails.getPassword());
  ```

  * If the passwords match, the authentication is successful.

#### 6. **Authentication Object is Populated**

* Upon successful authentication, the `AuthenticationProvider` creates a fully populated `Authentication` object:

  ```java
  Authentication authenticated = new UsernamePasswordAuthenticationToken(
      userDetails, null, userDetails.getAuthorities());
  ```

  * At this point, `isAuthenticated = true`.([frugalisminds.com][2])

#### 7. **Security Context Holder Stores Authentication**

* The authenticated `Authentication` object is stored in the `SecurityContextHolder`:

  ```java
  SecurityContextHolder.getContext().setAuthentication(authenticated);
  ```

  * This makes the authentication information available throughout the application.

#### 8. **Request is Forwarded to DispatcherServlet**

* The original request is now forwarded to the `DispatcherServlet`, which routes it to the appropriate controller method.([Medium][3])

* The controller can access the authenticated user's details:

  ```java
  Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
  String username = authentication.getName(); // "john_doe"
  ```

#### 9. **Authorization Checks**

* Before executing the controller method, Spring Security performs authorization checks based on the user's authorities.

  * For example, if the method is annotated with `@PreAuthorize("hasRole('ADMIN')")`, Spring Security checks if the authenticated user has the `ROLE_ADMIN` authority.

  * If the user lacks the required authority, an `AccessDeniedException` is thrown.

#### 10. **Controller Method Execution**

* If the user is authorized, the controller method is executed, and the response is generated.

* The response is sent back to the client, completing the authentication process.

---

### üß† Summary

This flow illustrates how Spring Security handles authentication requests:

1. **User submits credentials** via a login form.
2. **Security filters** intercept the request and extract credentials.
3. **AuthenticationManager** processes the credentials.
4. **AuthenticationProvider** verifies the credentials using `UserDetailsService`.
5. **Authentication object** is populated upon successful authentication.
6. **SecurityContextHolder** stores the authenticated `Authentication` object.
7. **Request is forwarded** to the `DispatcherServlet` for controller processing.
8. **Authorization checks** ensure the user has the necessary permissions.
9. **Controller method** is executed if authorized, and a response is generated.

If you have further questions or need more detailed examples, feel free to ask!

[1]: https://medium.com/%40rasheed99/introduction-on-spring-security-architecture-eb5d7de75a4f?utm_source=chatgpt.com "Introduction to Spring Security Architecture | by Rasheed Shaik | Medium"
[2]: https://frugalisminds.com/demystifying-how-authentication-works-in-spring-security/?utm_source=chatgpt.com "How Authentication Works In Spring Security ‚Äì FrugalisMinds"
[3]: https://medium.com/%40aprayush20/understanding-spring-security-authentication-flow-f9bb545bd77?utm_source=chatgpt.com "Understanding Spring Security Authentication Flow | by Ayush Singh | Medium"



==============================================================================

@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
    auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder());
}
|


working of above method:


@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Autowired
    private CustomUserDetailsService userDetailsService;

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(HttpSecurity http) throws Exception {
        AuthenticationManagerBuilder authenticationManagerBuilder =
            http.getSharedObject(AuthenticationManagerBuilder.class);
        authenticationManagerBuilder
            .userDetailsService(userDetailsService)
            .passwordEncoder(passwordEncoder());
        return authenticationManagerBuilder.build();
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
                .antMatchers("/login", "/register").permitAll()
                .anyRequest().authenticated()
            .and()
            .formLogin()
                .loginPage("/login")
                .permitAll()
            .and()
            .logout()
                .permitAll();
        return http.build();
    }
}




üîÑ How It Works
User Submits Credentials: The user provides their username and password through a login form.

Authentication Filter: The request is intercepted by an authentication filter (e.g., UsernamePasswordAuthenticationFilter). This filter extracts the credentials from the request and creates an Authentication object.

AuthenticationManager: The AuthenticationManager processes the authentication request. It delegates the authentication process to one or more AuthenticationProvider instances.

AuthenticationProvider: Each AuthenticationProvider handles a specific type of authentication. For username/password authentication, the DaoAuthenticationProvider is commonly used.

UserDetailsService: The AuthenticationProvider calls the UserDetailsService to load user-specific data. The UserDetailsService retrieves user information from a data source (e.g., database) and returns a UserDetails object.

Password Verification: The AuthenticationProvider compares the provided password with the stored password using the configured PasswordEncoder. If the passwords match, the authentication is successful.

Authentication Object Creation: Upon successful authentication, the AuthenticationProvider creates a fully populated Authentication object. This object contains the authenticated user's details and authorities.

Security Context: The Authentication object is stored in the SecurityContextHolder. This context holds the authentication information for the current thread of execution.

Authorization: After authentication, Spring Security uses the GrantedAuthority objects to perform authorization checks, determining what resources the authenticated user can access.

